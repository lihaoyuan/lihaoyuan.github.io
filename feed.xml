<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <generator uri="http://jekyllrb.com" version="4.0.1">Jekyll</generator>
  
  
  <link href="/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2020-08-04T14:05:08+00:00</updated>
  <id>//</id>

  
    <title type="html">lhy’s blog</title>
  

  
    <subtitle>努力，奋斗</subtitle>
  

  
    <author>
        <name>lhy</name>
      
      
    </author>
  

  
  
    <entry>
      
      <title type="html">Xv6 笔记（三）：锁</title>
      
      
      <link href="/2020/08/04/xv6-note-3/" rel="alternate" type="text/html" title="Xv6 笔记（三）：锁" />
      
      <published>2020-08-04T00:00:00+00:00</published>
      <updated>2020-08-04T00:00:00+00:00</updated>
      <id>/2020/08/04/xv6-note-3</id>
      <content type="html" xml:base="/2020/08/04/xv6-note-3/">&lt;p&gt;由于调度随时发生，而物理内存被多个 CPU 共享，所以两个 CPU 或线程有可能会同时访问同一个数据结构，如果不小心地限制并发访问，同时读写或同时写都可能会得到错误的结果、甚至损坏数据结构。有许多策略可以用来保持并发下代码的正确性，锁是其中常用的一种&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;锁具有互斥性，确保同一把锁在同一时间只有一个 CPU 可以持有，如果将锁与某个共享数据关联，并始终在持有锁的情况下访问数据，那么这个数据就在同一时间也只有一个 CPU 可以使用，在这种情况下，可以说锁保护了这个数据&lt;/p&gt;

&lt;p&gt;以链表为例&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码在串行环境中可以正确运行，但并行则会出错。假设有两个 CPU 同时在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt; 且都执行完了第 15 行，那么当它们先后执行第 16 行时，后执行的赋值会把先执行的 &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt; 结果覆盖掉，两次 &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt; 只增加了一个元素&lt;/p&gt;

&lt;p&gt;上面是竞争条件（race condition）的一个例子，当一个内存地址被并发访问，且其中至少有一个访问是写操作时，就会产生竞争条件，竞争的结果通常是 bug，要么其中一个写操作丢失，要么读到了还没更新完的数据，结果取决于 CPU 的执行顺序和内存操作顺序，所以 bug 通常不容易复现，加一行日志也可能改变上述顺序，使竞争消失&lt;/p&gt;

&lt;p&gt;当我们说锁保护了数据，实际上是指锁保护了关于数据的一些不变量（invariant）集合，不变量是指数据结构在操作过后依然保持一致的属性，一个操作的正确性常常取决于开始操作时数据的这些不变性是否为真。对于示例代码而言，数据的不变量是 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; 始终指向列表的第一个元素且每个元素的 &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; 指针指向下一个元素，而 第 15 行把 &lt;code class=&quot;highlighter-rouge&quot;&gt;l-&amp;gt;next&lt;/code&gt; 指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; 暂时破坏了数据的不变性（这时候 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; 指向的不是列表的第一个元素了），并在 16 行恢复，即这两行代码之间存在不变量被破坏的空隙，当像上面说的有两个 CPU 同时执行到这儿，操作了不变性为假的数据时结果就会出错。在第 15 之前、16 行之后加锁就可以保证不会有两个 CPU 同时执行这些代码，这两行代码常常称为临界区代码（critical section）&lt;/p&gt;

&lt;p&gt;逻辑上，自旋锁的实现应该是像下面这样的&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spinlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// does not work!&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但这个实现并不能保证并行环境下互斥，如果有两个 CPU 同时执行了 if 语句，都判断 &lt;code class=&quot;highlighter-rouge&quot;&gt;lk-&amp;gt;locked == 0&lt;/code&gt; 为真，就都会认为自己持有了锁并继续执行，出错的原因在于判断能否持有锁的代码和持有锁的代码之间存在空隙，这个过程不是原子性的&lt;/p&gt;

&lt;p&gt;由于锁的广泛使用，多核处理器通常会提供指令来解决上面所说原子性的问题，例如在 RISC-V 中，C 语言的内建函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sync_lock_test_and_set&lt;/code&gt; 会被编译成对 &lt;code class=&quot;highlighter-rouge&quot;&gt;amoswap r, a&lt;/code&gt; 指令的调用，后者将 r 的值与 a 指向的值交换，并返回 r 的旧值。例如假设有两个 CPU 同时执行到 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sync_lock_test_and_set(&amp;amp;lk-&amp;gt;locked, 1)&lt;/code&gt; 来持有同一把锁，先执行的 CPU 会在一条指令内把 &lt;code class=&quot;highlighter-rouge&quot;&gt;lk-&amp;gt;locked&lt;/code&gt; 设为 1 并读到 0 的旧值，后执行的 CPU 则只能读到 1，持有锁失败&lt;/p&gt;

&lt;p&gt;所以正确的自旋代码应该是像这样的&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spinlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__sync_lock_test_and_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;自旋锁在 while 循环中不停检测能否持有锁，在成功持有锁之前会一直占用着 CPU 资源，适用于临界区代码较少、持有后快速释放锁的场景，当确定能很快得到锁时，自旋会比上下文切换到其他进程更节省 CPU 资源。除了自旋锁外，xv6 还实现了另一种适用于其他场景的睡眠锁（sleep lock），当进程试图持有一个睡眠锁时，如果发现锁已经被其他进程持有，前者就会进入睡眠状态，将 CPU 资源让给其他进程，并在唤醒后重新检查锁的状态，再决定继续睡眠还是持有锁，与自旋锁相反，睡眠锁在睡眠和唤醒过程中存在大量的上下文切换，但不会长时间占用 CPU，所以更适合在耗时较长的任务中使用&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;acquiresleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleeplock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;锁通常在同一个函数里持有（acquire）和释放（release），但更恰当的用法是：在一系列需要确保原子性的操作前持有锁，并在这一系列操作结束后释放，如果这些操作在不同函数，甚至不同线程、不同 CPU 开始和结束，锁的持有和释放也应该这么做&lt;/p&gt;

&lt;p&gt;从表面上看，上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;acquiresleep&lt;/code&gt; 函数是标准的开头持有、结尾释放锁的结构。但实际上，代码持有用于保护 &lt;code class=&quot;highlighter-rouge&quot;&gt;lk-&amp;gt;locked&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;lk-&amp;gt;lk&lt;/code&gt; 自旋锁，在 while 条件里检测锁的状态为锁上后，就把 &lt;code class=&quot;highlighter-rouge&quot;&gt;lk-&amp;gt;lk&lt;/code&gt; 作为参数传给了 &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep&lt;/code&gt;，后者在获取到所在进程的 &lt;code class=&quot;highlighter-rouge&quot;&gt;p-&amp;gt;lock&lt;/code&gt; 之后，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;lk-&amp;gt;lk&lt;/code&gt; 给释放了，直到进程睡眠被唤醒后才重新持有它，然后返回到 &lt;code class=&quot;highlighter-rouge&quot;&gt;acquiresleep&lt;/code&gt; 继续执行，即在 &lt;code class=&quot;highlighter-rouge&quot;&gt;acquiresleep&lt;/code&gt; 整个函数的代码中， &lt;code class=&quot;highlighter-rouge&quot;&gt;lk-&amp;gt;lk&lt;/code&gt; 是在  &lt;code class=&quot;highlighter-rouge&quot;&gt;acquiresleep&lt;/code&gt; 函数被持有、然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep&lt;/code&gt; 中被释放、再在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep&lt;/code&gt; 函数被持有、在  &lt;code class=&quot;highlighter-rouge&quot;&gt;acquiresleep&lt;/code&gt; 函数释放的，正是上面说的在不同函数持有和释放的场景&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spinlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/* sleep and waked up */&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Reacquire original lock.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      
        <author>
            <name>lhy</name>
          
          
        </author>
      

      

      
        <category term="os" />
      
        <category term="xv6" />
      

      
        <summary type="html">由于调度随时发生，而物理内存被多个 CPU 共享，所以两个 CPU 或线程有可能会同时访问同一个数据结构，如果不小心地限制并发访问，同时读写或同时写都可能会得到错误的结果、甚至损坏数据结构。有许多策略可以用来保持并发下代码的正确性，锁是其中常用的一种</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">关于提高效率</title>
      
      
      <link href="/2020/07/06/efficiency/" rel="alternate" type="text/html" title="关于提高效率" />
      
      <published>2020-07-06T00:00:00+00:00</published>
      <updated>2020-07-06T00:00:00+00:00</updated>
      <id>/2020/07/06/efficiency</id>
      <content type="html" xml:base="/2020/07/06/efficiency/">&lt;p&gt;近段时间总结了一些提高效率的方法，写下来记录一下（可能不适用于任何人）&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;正念&quot;&gt;正念&lt;/h3&gt;

&lt;p&gt;又叫冥想，但就像在输入法里输“冥想”候选词里会出现 🧘‍♂️，在很多人印象里可能是一种像佛教徒打坐之类非常正式或者神秘的活动，所以这里用正念含义可能会更准确，iOS 自带的健康 App 里就有“正念训练”这一项，描述是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“正念”是一种积极、开放式感知当下的状态。进行正念训练时，您游离在一定距离之外来观察自己的思想和感觉，而不评判好坏。正念不会让岁月匆匆流逝，而是意味着活在当下，积极体验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看上去很玄乎，其实正念就是对思维（或者说骑象人）的一种训练，帮助大脑更好地控制思维。内心的大象总是会不受控制地冒出各种各样的想法，比如“刚才和谁谁谁聊天时，我是不是换一种方式来说这句话会比较好”、“需求里还有一个点忘了做了，快想想要怎么实现”，正念练习就是要训练思维在练习的过程中不去理会、思考、评判这些冒出来的想法，而是以一种游离的心态来观察自己的呼吸、身体感受或是周围的环境，活在当下。在观察而不思考的过程中，紧绷的神经也能得到片刻的休息&lt;/p&gt;

&lt;p&gt;我是从去年七月开始尝试用五到十分钟的正念来代替午觉的，一开始跟着 Now 上面的入门和限免课程来观察呼吸和身体，找到“游离”和“活在当下”的感觉，后来听听 Apple Music 上的冥想歌单也很容易进入状态&lt;/p&gt;

&lt;p&gt;回想起来，这一年的正念带来了什么呢？1. 花更短的午休时间得到了更好的休息质量；2. 就像卧推和飞鸟夹胸能让健身者更清晰地感受胸部各处肌肉的发力，正念也能让人感受到对思维的控制力，需要专注的时候抛开杂念、心无旁骛，休息时彻底放松神经&lt;/p&gt;

&lt;h3 id=&quot;番茄工作法&quot;&gt;番茄工作法&lt;/h3&gt;

&lt;p&gt;番茄工作法是一种简单的时间管理方法，把时间划分成一个个 25 分钟的番茄时间，在番茄时间内，专注于待办列表里的某个任务，尽量避免受外部干扰和打断，每过一个番茄时间休息 5 分钟，每过四个番茄时间休息 15 分钟&lt;/p&gt;

&lt;p&gt;在实践中，想要不被打断、完全按照计划表工作是不现实的，但也不可能所有事情都紧急且重要，我们可以尽量减少中断的次数，例如这个番茄时间内收到的 IM 消息或邮件攒到下个番茄时间再集中回复、提过来的 bug 等到每天固定的时间再改等等&lt;/p&gt;

&lt;p&gt;在我看来，关键是通过这种方式可以把工作时间划分一块块，这么做有几个好处：1. 在每块固定长度的工作时间中间插入一小段固定长度的休息时间，用来正念、喝水、上厕所、活动身体等，避免连续过长时间工作或休息（例如沉迷于难解的 bug 几小时不抬头，或是想短暂休息时打开了抖音，结果不知不觉过去了半小时）；2. 可以把番茄时间当作工作时间的一个衡量单位。市场上有很多番茄工作法 App，除了倒计时，还能帮助统计番茄时间的情况，而这些数据就是关于你工作效率的统计数据，我们可以通过完成的番茄时间数量看到这一天的有效工作时长，也可以观察一段时间内数据的变化做一些分析和回顾，更进一步还可以和待办列表相结合，统计为某个 bug 或功能点花的番茄时间数量，帮助评估工作效率以及在未来更好地预估需求开发耗时，就像做用户增长，有了数据和指标能更快找到问题所在和破解增长的办法&lt;/p&gt;

&lt;h3 id=&quot;找到满足感&quot;&gt;找到满足感&lt;/h3&gt;

&lt;p&gt;首先要把满足感和愉悦区分开，愉悦有很强的感官和情绪成分，比如美食、刷短视频等，通常是短期的，满足感则是当人们全心投入完成某些事情后充满能量且非常满足的感受，比如健身、阅读、装修自己的房子，需要付出更多努力和时间，但完成时也会得到更多快乐&lt;/p&gt;

&lt;p&gt;如果能在一项工作中（这里说的工作含义更加宽泛，不只指上班，也可以是学习或其它事情）找到满足感，甚至是体验“心流”，那么就能从工作中得到更多快乐，也就更加专注和高效&lt;/p&gt;

&lt;p&gt;但是在如今的大公司里，很多人只是巨大机器中的一颗小齿轮，可能与产品最终的成果关系也不大，要怎么找到满足感呢？一个方法是在工作中找一些比较有挑战性的事情去做，要么试着做的更深，要么试着做得更多，或是作为 owner 推动把事情做完做好，提高在团队中的影响力。如果都不能的话，还可以尝试在日常工作之外找一些能获得满足感的事情去做，白天的工作“把电用完”后，晚上花一些时间来“充电”，这些事情可以是学点新技术、看书、看电影或纪录片等，关键是这些事情持续做下去能让人有所收获，与带来短暂愉悦的事情有所区分，这并不是说要把手机里的娱乐类 App 卸掉，而是要对非工作时间也做一个简单的规划，例如不把所有的下班时间都用来刷抖音和闲聊，抽一个小时看纪录片或读书，从工作的烦恼中跳出来，个人感觉会更加充实&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>lhy</name>
          
          
        </author>
      

      

      
        <category term="thought" />
      

      
        <summary type="html">近段时间总结了一些提高效率的方法，写下来记录一下（可能不适用于任何人）</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">读《简单逻辑学》</title>
      
      
      <link href="/2020/05/17/being-logical/" rel="alternate" type="text/html" title="读《简单逻辑学》" />
      
      <published>2020-05-17T00:00:00+00:00</published>
      <updated>2020-05-17T00:00:00+00:00</updated>
      <id>/2020/05/17/being-logical</id>
      <content type="html" xml:base="/2020/05/17/being-logical/">&lt;p&gt;最近读了一本关于逻辑的小书《&lt;a href=&quot;https://book.douban.com/subject/24754537/&quot;&gt;简单的逻辑学&lt;/a&gt;》。这本书在豆瓣上褒贬不一，我觉得有一部分原因是书名的翻译，它不是一本严肃的逻辑学教科书，而是“一本现实应用指南，向那些初次接触逻辑学的人介绍逻辑学的基本原理”，原书名“&lt;em&gt;Being Logical: A Guide to Good Thinking&lt;/em&gt;”更贴切地描述了它的内容。在我看来，学习逻辑更多的是关于如何思考和看待事物；更多关于说服自己，而不是说服别人，在这一点上，这本书是有所启发的&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;下面是一些内容的摘录&lt;/p&gt;

&lt;h3 id=&quot;关于沟通&quot;&gt;关于沟通&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们大脑中的每个观念最终都源于对事物的描摹，而真实存在的事物却独立于观念之外。观念是对客观事物的主观反映。&lt;/p&gt;

  &lt;p&gt;首先是事物，然后产生观念，最后出现语言。即使一个观念清晰明确而且忠实地反映了客观事物，为了交流的方便，我们也应该用语言表达出来。观念必须和语言紧密切合，人们才能畅顺交流。很多时候，我们不能清楚表达我们的观念，仅仅是因为没有完全了解自己要表达什么。所以，回头重新审视观念的外在来源，理清思路，合适的表达将随之而来。&lt;/p&gt;

  &lt;p&gt;不要想当然地认为你的听众会领悟你没有直接表达的意思。问题越复杂，这个原则越重要。有时，我们想当然地认为听众和我们一样了解问题的背景信息，可以牢牢把握所要讨论的问题，但实际上，可能很多听众对这些信息根本一无所知。当我们拿不准的时候，最好能清楚地讲明背景信息；唠唠叨叨总比挂一漏万强。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;语言作为传递思想的媒介是不完美的，一方面发言者可能自己也没有想明白自己的观念，自然就不能清楚地表达给别人听；另一方面词语常常是多义的，同样的思想可以用不同的语言形式来表达，同一句话也可以被解释成不同思想，这就需要发言者为听者提供足够多的上下文，来消除这些模糊地带。不管是对发言者还是听者，“用你自己的话来说”都是检测是否弄清楚一个观念的最佳方法，发言者可以通过说或写理清思绪、改善表达，听者可以通过用完全不同的用语说出同样的观念来确定自己了解了对方的观念&lt;/p&gt;

&lt;h3 id=&quot;关于比较&quot;&gt;关于比较&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;要对比任何两个事物，特别是庞大复杂的事物，像历史事件之类，要谨记不能仅仅因为在比较时我们注意到了很多相似之处，就鲁莽地得出诸如“这两个事件很相似”之类的结论。问题的关键并不是相似特征的多少，起决定作用的是这些相似特征的重要性。如果一个性质揭示了事物的本质，那么它就是重要的，它揭示了事物本身的特性。&lt;/p&gt;

  &lt;p&gt;如果一个主要特性被遗漏，那么即使有大量相似的其他特性，也不能作出可靠的比较结论。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一些自媒体常常用现实中的一些蛛丝马迹与历史事件发生时也出现过的现象做比较，得出即将发生危机之类的结论，来吸引眼球和关注度。例如最近很火的《腾讯的背水一战》里举了诺基亚的例子，给人一种腾讯大厦将倾的感觉，但几年一换的手机硬件和微信等互联网基础设施适合比较吗？我觉得可比性不高&lt;/p&gt;

&lt;h3 id=&quot;关于怀疑&quot;&gt;关于怀疑&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果把怀疑论作为一个长久的态度，从心理学的角度来说，是极度危险的。它在开始推理之前就已经设下障碍，扭曲推理的正确进程。持这种态度的怀疑论，表现形式有两种：极端怀疑论者宣称世界上根本没有所谓的真相。这明显是自相矛盾的结论，因为如果这世界上没有真相，就无法对上述命题加以判断，由此这个结论根本就是无根之花。中度怀疑论者勉强承认这个世界上或许有真相存在，但是他坚持，即使真相存在，人类也没有能力探知它。初看起来，和极端怀疑论者相比，这个结论似乎给了真相一席之地，但事实上并非如此。真相如果只存于理论上，不能通过实践去检验，那它还是不存在的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;论证不是争吵&quot;&gt;论证不是争吵&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;论证是理性的探讨，不要将它和争吵混为一谈。论证的目的是发现真相，争吵的目的是击败你的对手。有许多人，虽然他们愿意和你争吵，但却不愿意或者没能力和你进行论证。不要浪费时间、精力和这种人进行争论。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;罗翔老师在《&lt;a href=&quot;https://www.bilibili.com/video/BV1rk4y1R7id/&quot;&gt;聊聊网络喷子与键盘侠&lt;/a&gt;》表达了类似的观点：“很多人会说为什么网络喷子说话经常不讲逻辑？因为很多时候，网络喷子是在吵架，吵架要讲逻辑吗？讲逻辑那叫论证，吵架是不用讲逻辑的”。网络喷子是辩不赢的，很多时候他们只是在单纯地发泄负面情绪，或出于某些原因煽动别人的负面情绪，不要和他们争论&lt;/p&gt;

&lt;h3 id=&quot;以暴易暴&quot;&gt;以暴易暴&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“因为__&lt;strong&gt;已经做了&lt;/strong&gt;__ ，所以现在__&lt;strong&gt;可以做&lt;/strong&gt;__。”空格的选项可以是人类的任何行为，从善意举止到丑恶罪行。&lt;/p&gt;

  &lt;p&gt;这个论证的推理有赖于如下假设：先例独立决定未来的行为。实际上先例不能为未来的行为提供有效的支持，已经完成的行为只有历史意义。在决定先例是否有借鉴意义时，我们的关注点应该是事物本身的性质。&lt;/p&gt;

  &lt;p&gt;“他们先做了，所以我们应该以牙还牙。”但是，如果他们所做的是错的，我们的行为就成了一种报复，双方都是错的也不能使这种行为立刻变成对的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我觉得也可以表述为“就事论事”，这并不是要求人们对任何事上都打不还手，而是要清楚意识到，对方的错误行为并不能使自己的错误行为变成对的，例如视频网站搞超前点映之类恶心的商业行为，并不能使看盗版、甚至传播盗版成为一件正义的事，况且后者还可能是犯罪&lt;/p&gt;

&lt;h3 id=&quot;关于偏见&quot;&gt;关于偏见&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;现在假设你是一个声誉斐然的公司的人事经理。作为工作的一部分，你对全国著名的大学和学院知之甚多，并且对毕业生的基本情况了如指掌。尤其，你知道X学院在这个领域内声名狼藉。目前，你的公司正在招聘一个重要的职位。在浏览候选人资料时，你看到一个X学院的毕业生，彼得，于是你立刻决定拒绝他进入下一轮，这仅仅是因为他所毕业的学校。这个时刻，你已经产生了谬误。&lt;/p&gt;

  &lt;p&gt;不是说你的决定完全不合理。毕竟，以你对X学院的了解，彼得或许确实不是一名合格的人选。但是，这不是必然的。一颗闪亮的新星是可能出自于类似X学院之类的学校的。你所犯谬误的根源如下：知道一个来源一般是坏的，于是认定出于这个来源的所有都一定是坏的。这并不必然成立。&lt;/p&gt;

  &lt;p&gt;考虑我们所考察的人或事的出身肯定是必要的。但是我们必须走得更远。首先我们要问：彼得从哪里来？紧接着，更关键的问题是：他的品质如何？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;无意识偏见普遍存在，并实实在在地影响着我们的生活和工作。除了常见的对性别、外貌特征的负面偏见外，还存在着一些我们同样没意识到的正面偏见，例如可能很难理解为什么重点大学学生也会有偷外卖、私占共享单车之类的低素质行为，事实上一个学生能上好大学的主要原因就是高考成绩好，不是素质或者别的什么，当然成绩好的学生也有可能会同时受到了更好的人文教育、读了更多的书，但重点大学学生这个身份并不足以倒推出这些，所以也就可以理解那些低素质行为的出现了&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>lhy</name>
          
          
        </author>
      

      

      
        <category term="thought" />
      

      
        <summary type="html">最近读了一本关于逻辑的小书《简单的逻辑学》。这本书在豆瓣上褒贬不一，我觉得有一部分原因是书名的翻译，它不是一本严肃的逻辑学教科书，而是“一本现实应用指南，向那些初次接触逻辑学的人介绍逻辑学的基本原理”，原书名“Being Logical: A Guide to Good Thinking”更贴切地描述了它的内容。在我看来，学习逻辑更多的是关于如何思考和看待事物；更多关于说服自己，而不是说服别人，在这一点上，这本书是有所启发的</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Xv6 笔记（二）：调度</title>
      
      
      <link href="/2020/05/11/xv6-note-2/" rel="alternate" type="text/html" title="Xv6 笔记（二）：调度" />
      
      <published>2020-05-11T00:00:00+00:00</published>
      <updated>2020-05-11T00:00:00+00:00</updated>
      <id>/2020/05/11/xv6-note-2</id>
      <content type="html" xml:base="/2020/05/11/xv6-note-2/">&lt;p&gt;操作系统的一项主要工作是在多个程序间共享计算机的资源，让它们可以同时（或看起来像同时）运行。程序是在进程中执行的，同时运行多个程序实际上就是同时运行多个进程。进程往往比 CPU 多，所以就需要一个机制来让多个进程间分时共享 CPU（time-sharing）&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;理想情况下，这种共享对用户进程应该是透明的。一种常见的方法是通过将每个进程多路复用（multiplexing）到硬件 CPU 上，从而为每个进程提供它们拥有自己的虚拟 CPU 的错觉。要做到这一点，需要 CPU 在切换进程前，先记下旧进程的运行状态（或者叫上下文），等到下次它被唤醒时，再把之前的运行状态恢复回来，继续执行切换前要执行的指令，就好像没有发生过切换一样。这里的上下文就是进程（或者说线程，xv6 未支持多线程）的寄存器。保存和恢复 SP 和 PC 寄存器就意味着 CPU 切换了栈和正在执行的代码&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/assets/xv6-note-2/image-20200501112421478.png&quot; alt=&quot;image-20200501112421478&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图简单描述了用户进程切换的过程：1. 旧用户进程通过系统调用或中断切换到它的内核线程；2. 一次上下文切换（swtch）到 CPU 的调度器（scheduler）线程；3. 又一次上下文切换到新进程的内核线程；4. 从新线程的内核空间回到用户空间继续执行。每个 CPU 都有自己的调度器线程，它实际上就是一个寄存器值和栈的组合，在进程切换过程中恢复和保存。在单独的线程做这件事有助于抽象和简化调度逻辑，如果在旧进程的里做调度，其他 CPU 唤醒旧进程时会继续执行 swtch 之后的代码，这时进程的栈还是前一个 CPU 调度留下的，两个核使用同一个栈可能会带来很多问题&lt;/p&gt;

&lt;p&gt;Xv6 在两种情况下会把 CPU 从一个进程切换到另一个：1. Xv6 会定时强制切换长时间运行的进程；2. 进程通过 sleep/wakeup 机制主动进入等待（设备/IO/子进程退出之类的）&lt;/p&gt;

&lt;p&gt;前者是由定时器中断触发的，定时器中断源于与每个 RISC-V CPU 关联的时钟硬件，xv6 在启动时会在机器模式下修改 CLINT 硬件（core-local interruptor），生成一个在一定延迟后触发的中断，并配置中断处理程序和相关寄存器，开启中断开关。经过指定延时之后，硬件生成的中断会回调到定时器中断处理程序（timervec），后者再次修改 CLINT 硬件来配置下一次中断，然后向内核抛一个软件中断并返回。这里之所以不直接把时间中断交给内核处理是因为 RISC-V 要求定时器中断只能在机器模式配置和接收，运行在管理员模式的内核无法禁用它，但软件中断是可以禁用的，所以抛软件中断可以让内核自行配置是当前是否处理中断，以免关键操作被意外打断&lt;/p&gt;

&lt;p&gt;抛出的软件中断后内核或用户进程通过 trap 机制暂停当前正在执行的代码，转而走到相应的处理程序，中断处理程序从特定寄存器读到是定时器中断，便调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 暂停执行、释放 CPU，从而进入调度逻辑&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在三种情况下一些事件会导致 CPU 搁置正在执行的指令序列，强制转向执行用于处理该事件的特殊代码：1. system call，用户程序通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecall&lt;/code&gt; 调用内核服务，引起 CPU 从用户模式转向管理员模式执行内核代码；2. exception，用户或内核执行了非法指令（除以 0、访问非法地址等），抛出异常；3. 设备中断，硬件设备执行完读写等操作时会触发来引起关注。这几种情况统称为 trap，处理中断的特殊代码为 trap handler&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;上下文切换机制可以让中断和进程切换对用户进程透明，但还是需要有一种机制来让进程能主动让出 CPU，进入等待被某些事件唤醒的状态，例如 console 程序可以在用户没有输入进入睡眠状态，让 CPU 先执行其他进程，在收到用户输入的事件后再被唤醒和处理输入的字符。Xv6 里实现这一机制的是 sleep 和 wakeup，也常叫条件同步（conditional synchronization）。进程 sleep 时监听的条件或事件称为 sleep channel（内核里的 sleep  channel 通常是某些数据结构的内存地址），例如当用户用键盘输入的字符时，xv6 会收到一个 RISC-V 的设备中断，检查发现是来源是用户输入后就从特定的物理地址读取输入的字符，添加到 console 的输入字符 buffer 里并通过监听的 channel 唤醒 console&lt;/p&gt;

&lt;p&gt;多个进程可以同时监听同一个 channel，条件触发时 &lt;code class=&quot;highlighter-rouge&quot;&gt;wakeup&lt;/code&gt; 会把所有正在监听的进程设为可运行状态，然后由调度机制来把它们唤醒。如果唤醒的条件是某些资源（例如 pipe），只能被使用一次，那么这一资源只有第一个操作系统被唤醒的进程能消费到，后被唤醒的其他进程会发现条件不满足（资源没有了），唤醒只是一个“误会”，便再次进入睡眠和等待，这一现象叫做惊群问题（&lt;a href=&quot;https://en.wikipedia.org/wiki/Thundering_herd_problem&quot;&gt;thundering herd problem&lt;/a&gt;），大量进程被误唤醒后再进入 sleep 会导致大量 CPU 资源被浪费在上下文切换上。解决问题的一种办法是把需要和不需要唤醒所有等待进程的 &lt;code class=&quot;highlighter-rouge&quot;&gt;wakeup&lt;/code&gt; 调用明确区分成两个函数，在只需要唤醒一个进程的场景用 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal&lt;/code&gt;，需要唤醒多个进程的用 &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt;；另一种思路是用信号量，明确指出有多少资源或唤醒次数可用&lt;/p&gt;

&lt;p&gt;使用 sleep/wakeup 机制的另一个例子是另一对与调度相关的系统调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;。前者用于等待子进程退出，调用后会以当前进程数据结构的地址为 sleep channel 进入睡眠状态；后者供进程主动终止运行，进程结束运行后内核会尝试用父进程的地址作为 channel wakeup，这样如果有父进程在等待子进程退出，就会被唤醒并收到子进程的退出状态码&lt;/p&gt;

&lt;p&gt;Xv6 在调度进程时采用的只是简单的轮询方案（遍历进程表找到一个可运行的进程然后运行它），现实中的操作系统往往会有更完善的调度方案来满足实际需求，例如引入进程优先级的概念，同时为了确保公平（低优先级进程也能得到执行）和高吞吐量，方案还会变得更加复杂，导致出现优先级反转（&lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_inversion&quot;&gt;priority inversion&lt;/a&gt;，高优进程等待低优进程释放它持有的资源，但低优进程又得不到 CPU 资源来完成执行）、锁巡航（&lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_convoy&quot;&gt;lock convoy&lt;/a&gt;，多个高优进程等待低优进程释放资源，CPU 资源会一直被浪费在高优进程的上下文切换中）等问题，解决这些问题又进一步增加了调度机制的复杂度&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>lhy</name>
          
          
        </author>
      

      

      
        <category term="os" />
      
        <category term="xv6" />
      

      
        <summary type="html">操作系统的一项主要工作是在多个程序间共享计算机的资源，让它们可以同时（或看起来像同时）运行。程序是在进程中执行的，同时运行多个程序实际上就是同时运行多个进程。进程往往比 CPU 多，所以就需要一个机制来让多个进程间分时共享 CPU（time-sharing）</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Xv6 笔记（一）：隔离</title>
      
      
      <link href="/2020/04/21/xv6-note-1/" rel="alternate" type="text/html" title="Xv6 笔记（一）：隔离" />
      
      <published>2020-04-21T00:00:00+00:00</published>
      <updated>2020-04-21T00:00:00+00:00</updated>
      <id>/2020/04/21/xv6-note-1</id>
      <content type="html" xml:base="/2020/04/21/xv6-note-1/">&lt;p&gt;当一个应用程序执行出错时，我们不希望操作系统或其他不相关的程序因此也出错，相反，操作系统应该要能发现并清理掉出错的程序，并继续运行其他程序。要实现有效的隔离首先要求操作系统和应用程序之间有明确的界限，普通程序不能写（甚至读）系统的数据结构和指令，也不能访问其他进程的内存&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;CPU 为隔离提供了硬件上的支持。例如 RISC-V 指令集提供了下列三种指令执行模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;机器模式（machine mode）：有完整的执行权限，主要用于启动时初始化计算机配置&lt;/li&gt;
  &lt;li&gt;管理员模式（supervisor mode）：可以执行特权指令（privileged instruction），例如开关中断、读写一些特定的寄存器等。如果运行在用户模式下的执行特权指令，CPU 不会执行，而是会切到管理员模式并在管理员模式下杀掉试图越界的程序。运行在管理员模式（或者说内核空间）的软件称为内核&lt;/li&gt;
  &lt;li&gt;用户模式（user mode）：程序代码只能执行用户模式指令，CPU 提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecall&lt;/code&gt; 指令来让用户模式下的程序切换到管理员模式并进入内核指定的入口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Xv6 整个操作系统运行都在管理员模式下（&lt;a href=&quot;http://en.wikipedia.org/wiki/Monolithic_kernel&quot;&gt;宏内核&lt;/a&gt;），而普通程序只能运行在用户模式，这样，&lt;strong&gt;通过 CPU 指令执行模式的限制就可以确保系统和程序间的隔离&lt;/strong&gt;，程序只能通过内核提供的系统调用接口使用内核提供的服务，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;wirte&lt;/code&gt; 等，内核可以先检查确保参数和程序权限合法，再真正调用服务&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/assets/xv6-note-1/image-20200418232330934.png&quot; alt=&quot;system call&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和其它 Unix 操作系统一样，进程也是 xv6 的基本隔离单位。为帮助实现程序间隔离，进程机制为每个程序制造了它有一整台私有计算机的假象，程序”拥有“一个私有的内存系统（或者叫地址空间）和一个单独的 CPU 来执行它的指令。前者通过硬件提供的&lt;strong&gt;页表&lt;/strong&gt;实现，RISC-V 使用页表把虚拟地址（RISC-V 指令操作的地址）映射到物理内存的地址上，xv6 为每个进程维护独立的页表，构成进程的地址空间&lt;/p&gt;

&lt;p&gt;Xv6 所运行的 Sv39 模式使用 39 位的虚拟地址（64 位地址的前 25 位未使用），地址被分为三个 9 位的 VPN（virtual page number）和一个 12 位的页偏移量&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/assets/xv6-note-1/image-20200419144315632.png&quot; alt=&quot;Sv39 virtual address&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;存储在物理内存中的页表是一棵三层的树，树的根节点是一个 4096 字节的页表页（大小与物理内存中的页对齐），包含 2&lt;sup&gt;9&lt;/sup&gt; 个 8 字节的 PTE（page table entry），每个 PTE 包含指向下一层页表页的物理地址（和低 10 位描述 PTE 信息的标记位），第二层的每个页表页又包含 2&lt;sup&gt;9&lt;/sup&gt; 个指向第三层页表页的 PTE。页表硬件使用虚拟地址的高九位 VPN[2] 作为索引从根节点得到一个指向第二层页表页的地址，然后用 VPN[1] 从第二层获取第三层页表页的地址，最后通过 VPN[0] 选中最后的 PTE，从中获取 44 位的物理地址，拼上虚拟地址最后 12 位的偏移量，得到一个 56 位的物理地址，就是这个虚拟地址所映射的物理地址&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/assets/xv6-note-1/image-20200419150955605.png&quot; alt=&quot;page table&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 CPU 都有各自的 satp 寄存器（supervisor address translation and protection register），当把页表树根节点的物理地址写到 satp 后，CPU 后续执行的所有指令中的地址都会用这个页表来转换&lt;/p&gt;

&lt;p&gt;当用户进程的内存分配器（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;）通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;sbrk&lt;/code&gt; 申请内存时，内核会按上述转化逻辑依次访问（或生成，如果没有的话）各层对应的 PTE，把新申请到的物理内存的地址保存到第三层的 PTE 里，然后向用户进程返回该虚拟地址；当用户进程访问某个虚拟地址时，如果地址转化过程中遇到的任意一个 PTE 不存在或一些标记与访问类型不符—-即程序访问了一个非法地址，分页硬件就会抛出页错误异常（page-fault）&lt;/p&gt;

&lt;p&gt;这种三层结构允许页表懒加载页表页，很大范围内的虚拟地址的页表页没被访问就不会生成出来&lt;/p&gt;

&lt;p&gt;通过页表，每个进程都拥有完整连续的虚拟地址（0～MAXVA），而实际的物理地址可以是不连续的；同时页表还可以把同一片物理内存映射到不同地址空间，在不同进程间复用同一份代码（例如每个进程用户地址空间都有的 trampoline 页）。内核有单独的页表，不同进程也有各自的页表，把虚拟地址转换成不同的物理内存页地址，从而实现程序间内存的隔离&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>lhy</name>
          
          
        </author>
      

      

      
        <category term="os" />
      
        <category term="xv6" />
      

      
        <summary type="html">当一个应用程序执行出错时，我们不希望操作系统或其他不相关的程序因此也出错，相反，操作系统应该要能发现并清理掉出错的程序，并继续运行其他程序。要实现有效的隔离首先要求操作系统和应用程序之间有明确的界限，普通程序不能写（甚至读）系统的数据结构和指令，也不能访问其他进程的内存</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">5G 未来（译文）</title>
      
      
      <link href="/2020/03/16/a-5g-future/" rel="alternate" type="text/html" title="5G 未来（译文）" />
      
      <published>2020-03-16T00:00:00+00:00</published>
      <updated>2020-03-16T00:00:00+00:00</updated>
      <id>/2020/03/16/a-5g-future</id>
      <content type="html" xml:base="/2020/03/16/a-5g-future/">&lt;blockquote&gt;
  &lt;p&gt;这是一篇英文文章的中文翻译&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;This is a Chinese translation of the English language article:&lt;br /&gt;&lt;/strong&gt;
&lt;strong&gt;Loukides, Mike. “A 5G future”&lt;br /&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;a href=&quot;https://www.oreilly.com/radar/a-5g-future/&quot;&gt;https://www.oreilly.com/radar/a-5g-future/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在过去的一年里，5G 通信技术引起了很多人的兴奋，也引发了不少炒作。5G 的技术指标令人瞩目：它将为手机、智能汽车和很多还没发明出来的移动设备提供高达 20 Gbps 的&lt;a href=&quot;https://www.etsi.org/technologies/5g&quot;&gt;峰值数据传输速率&lt;/a&gt;（“&lt;a href=&quot;https://5gobservatory.eu/info-deployments/5g-performance/&quot;&gt;用户体验的数据传输速率&lt;/a&gt;”为 100 Mbps）。很难想象什么样的 app 会需要如此多的数据，而 5G 支持者们似乎觉得一切皆有可能。5G 在实践中意味着什么？我们需要好好想想它能为现实世界带来什么样的变化。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;5G 可能带来的最显著变化不在于手机，而在于本地网络，无论是家庭的还是办公室的。早在 80 年代 Nicholas Negroponte 就&lt;a href=&quot;https://books.google.com/books?id=McBUx67rw7wC&amp;amp;pg=PA338&amp;amp;lpg=PA338&amp;amp;dq=negroponte+everything+wired+will+become+wireless,+and+everything+wireless+will+become+wired.&amp;amp;source=bl&amp;amp;ots=cJTyDDyWhR&amp;amp;sig=ACfU3U14LnXEcU_lGE6lm5jHFk30-mCQ1w&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=2ahUKEwiRsZOD7-DlAhWsuFkKHZg9CqwQ6AEwBXoECAkQAQ#v=onepage&amp;amp;q=negroponte%20everything%20wired%20will%20become%20wireless%2C%20and%20everything%20wireless%20will%20become%20wired.&amp;amp;f=false&quot;&gt;说过&lt;/a&gt;，一切有线的东西都会变成无线，而一切无线的东西都会变成有线。对于网络连接的“最后一英里”会发生什么变化呢？现在家庭网络似乎停留在了 50 Mbps 左右，商用网络则稍高一些，如果有别的高带宽选择来打破本地电信运营商的垄断会非常不错，不是每家每户都有光纤，对吧？5G 带来的高速网络也许会推动下一代“&lt;a href=&quot;https://en.wikipedia.org/wiki/Cord-cutting&quot;&gt;剪线族&lt;/a&gt;”的出现，它能取代有线宽带，成为家庭和移动设备的一个无线服务吗？我不需要更高的带宽来开视频会议或看电影，但确实希望能只花几秒而不是几分钟来下载一个系统更新和大文件。每个建过 Docker 容器的人都经历过“现在得等一些大文件下载和解压”的时刻，就算你用的是公司网络，也需要等不少时间。这个可能会随着 5G 到来而消失。&lt;/p&gt;

&lt;p&gt;农村网络连通性是个老生常谈问题，许多农村用户（和一些城市用户）仍然只能使用拨号速度的网络。尽管企业&lt;a href=&quot;https://www.zdnet.com/article/the-realities-of-rural-5g-deployment-in-the-us/&quot;&gt;声称&lt;/a&gt; 5G 将为农村地区提供更好的连通性，但我深表怀疑，因为 5G 使用的是比 4G 更高的频率，而更高的频率更易受路径损耗的影响，5G 基站的覆盖范围肯定会比 4G/LTE 基站小，如果运营商在现有技术下不愿建基站塔，那他们多半也不愿为 5G 建更多塔。所以我猜农村社区会再次被落下。&lt;/p&gt;

&lt;p&gt;以当下手机和嵌入式设备的发展，除了在旅途中用手机来发 Wi-Fi，我不觉得为什么我会需要上千兆的网络。用手机来看电影会很痛苦，待会会谈到这个。5G 热衷者常说它是自动驾驶汽车（AV）的一项使能技术，因为后者会需要高带宽来下载地图和图片，汽车间甚至可能互相交流：在未来的自动驾驶汽车世界里，所有汽车都是自动驾驶的，可以协同规划交通。这个可能很需要 5G 来支持，但再一次地，我很好奇谁会去投资建设农村网络，要是自动驾驶汽车只能在城市里开，那就没那么有用了。对于像自动驾驶汽车间交流这样的场景，相比原始带宽，延迟（多久能收到回复）更有可能是个更大的限制，并且是受物理限制，尽管对 5G 的延迟有令人印象深刻的&lt;a href=&quot;http://www.techplayon.com/5g-nr-control-plane-latency-calculations/&quot;&gt;估计值&lt;/a&gt;，但在实际使用中往往会受到更严苛的考验。可靠性会是一个比延迟更大的问题，还记得你上次去纽约或旧金山是什么样吗？由于信号会在高楼大厦间反射，并在穿过时衰减，大城市的通信服务常常很差，信号频率变高时这些问题会更加严重。不管是自动驾驶汽车还是其他应用场景，提高移动连接的可靠性比提速更重要。5G 打算通过权衡信号质量来解决这个问题，这么做看起来是有道理的，但是否有效尚待观察。&lt;/p&gt;

&lt;p&gt;正在研究&lt;a href=&quot;https://learning.oreilly.com/library/view/tinyml/9781492052036/&quot;&gt;让机器学习运行在超低功耗设备上&lt;/a&gt;的 Pete Warden 表示，5G 对他所关心的应用场景用处不大，当试着做一个能用纽扣电池运行数月的设备时，你会发现无线网络模块耗电比 CPU 还多，所以你必须尽可能保持无线模块关闭，传尽量少的数据。那工作物联网（lloT）和可以放在&lt;a href=&quot;https://www.oreilly.com/radar/tinyml-the-challenges-and-opportunities-of-low-power-ml-applications/&quot;&gt;贴纸&lt;/a&gt;里贴到机器上的传感器呢？这可能是 5G 的一个应用场景，但正如 Warden 所说，这种场景中真正的胜利是消灭电池和电源线，这反过来又要求谨慎地使用低功耗网络，5G 并非理想选择，且初步看来它比现有技术功耗更高。&lt;/p&gt;

&lt;p&gt;抛开功耗不谈，我也不觉得未来会有很多 loT 设备有发送数据的需求。我们已经见识过公众对亚马逊的 Echo 和 Google Home 把对话记录发回给服务器的新闻会作何反应了，我们也已经看到过像智能恒温器和灯泡这样的设备被用于&lt;a href=&quot;https://www.nytimes.com/2018/06/23/technology/smart-home-devices-domestic-abuse.html&quot;&gt;骚扰&lt;/a&gt;。随着隐私法规的完善和&lt;a href=&quot;https://ai.googleblog.com/2017/04/federated-learning-collaborative.html&quot;&gt;联邦学习&lt;/a&gt;这样的技术普及，远距离传输用户数据的需求和欲望将不可避免地减少。&lt;/p&gt;

&lt;p&gt;那 5G 到底在哪里能派上用场？让我们回到家庭网络，我会很乐意为千兆无线网放弃我的 50 Mbps 有线网络。同样的，这是终极剪线，创造了巨大的新的可能性，我可能不想在手机上看 4K 视频（考虑到现有屏幕技术，手机上的高分辨率视频意义不大，更别提说人眼的角分辨率了），但我可能会想用 Chromecast 把手机上的视频传到电视上看。&lt;/p&gt;

&lt;p&gt;我对我现在的 Wi-Fi 部署很满意，但在 5G 世界中我还需要 Wi-Fi 吗？也许出于安全和隐私考虑，把本地网络和外网分隔开也说得通，但这同样是一个 5G 运营商可以解决的问题，虚拟局域网（&lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_LAN&quot;&gt;VLAN&lt;/a&gt;）早已不是新概念了，笔记本电脑连接千兆网络，加上蜂窝网络提供一个 VLAN，也可以取代掉办公网。无论哪种情况都于需要对隐私和安全做严格的保证，从现有&lt;a href=&quot;https://www.privacypolicies.com/blog/isp-tracking-you/&quot;&gt;运营商追踪用户的记录&lt;/a&gt;来看，还有太多问题要问。&lt;/p&gt;

&lt;p&gt;如果能得到运营商所提供的 VLAN 对隐私和安全的强制保证，我可以想象更大的变革了。长期以来我一直认为，维护经常发生故障且需要备份的硬盘（无论是机械还是固态）没什么意义，我会定期备份数据，但我知道我是少数人。如果所有数据都存在云端、访问速度快到延迟可以忽略会怎样？如果你所有的文档都存在 Google Docs、所有的音乐都在你最喜欢的流服务里呢？这并不是新的愿景，早在九十年代 Sun 就提出了这个想法，它实质上就是谷歌 Chromebook 背后的愿景。&lt;/p&gt;

&lt;p&gt;5G 会如何改变我们对网络的使用方式呢？假如我有 30 或 40 GB 的照片，我可以把它们全部上传到 Google Photos 或其他服务里，但你不会想用 50 Mbps 下载和 10 Mbps 上传的网络做这种，但如果是上千兆的网络，就不用考虑了。我一直对音视频流媒体兴趣不大，有一部分原因是它们常常在你最需要的时候不可用：飞机或火车上，或是在一个 3000 人参加、把酒店网络挤爆的技术会议（真有人曾跟我说过“那你应该在出发前把所有想听的东西下下来”），但如果有千兆带宽的微型基站，这些流媒体就有用了。也许不是对飞在基站范围外的飞机（WoeFi 仍将保持正常运行），可能不是对开在农村的车，但如果我的手机能用上千兆的网络，那我为什么还要在意 Amtrak 缓慢的 Wi-Fi 和酒店的网络拥堵呢？如果办公室可以给我的笔记本提供这样的带宽，并对云安全提供足够的保证，为什么我们还要担心办公室局域网呢？&lt;/p&gt;

&lt;p&gt;不管你喜不喜欢，在我看来，这会是一个全新的模式：我们不需要管数据存哪了，不用担心备份，也不用担心停电，我们随身携带自己的网络，甚至不需要担心安全问题，Google、Amazon 和 Microsoft 都比我更擅长备份和应对网络中断，而且非常清楚如何保护我的数据。如果 Google 能推动用户打开&lt;a href=&quot;https://authy.com/what-is-2fa/&quot;&gt;双因素验证&lt;/a&gt;（2FA）或用&lt;a href=&quot;https://www.extremetech.com/computing/274067-google-eliminated-phishing-by-giving-all-85000-employees-usb-security-keys&quot;&gt;安全加密狗&lt;/a&gt;，这会是迈向计算机安全的重要一步。这些云服务会、也必须保证这些数据的隐私性，就像数据保存在用户自己硬盘或办公室机房一样，这是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/FBI–Apple_encryption_dispute&quot;&gt;很容易解决&lt;/a&gt;的问题。&lt;/p&gt;

&lt;p&gt;对商业的影响会更加重要，家庭用户想要千兆网络，而企业会需要到兆兆或千兆兆。当千兆网络无处不在时，移动大型数据集会简单得多。不管是 AI 应用的训练数据还是交易记录，企业总是移动数据、很多数据，在现有技术下，移动大量数据的最好方法通常是把&lt;a href=&quot;https://aws.amazon.com/snowmobile/&quot;&gt;硬盘放在卡车上&lt;/a&gt;，如果安全和隐私能得到硬性保证的话，5G 就能让我们更接近于解决这个问题了，企业比普通用户更不希望让第三方使用他们的数据。&lt;/p&gt;

&lt;p&gt;我相信 5G 还会带来可以用上这种带宽的、我们还没想像出来的新一代智能设备，但我还是更关心我现在能想象到的，与自己的数据脱钩：随时随地访问、无需随身携带或存在柜子里的某些机器上，这才是 5G 真正的前景。&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>lhy</name>
          
          
        </author>
      

      

      
        <category term="translations" />
      

      
        <summary type="html">这是一篇英文文章的中文翻译 This is a Chinese translation of the English language article: Loukides, Mike. “A 5G future” https://www.oreilly.com/radar/a-5g-future/ 在过去的一年里，5G 通信技术引起了很多人的兴奋，也引发了不少炒作。5G 的技术指标令人瞩目：它将为手机、智能汽车和很多还没发明出来的移动设备提供高达 20 Gbps 的峰值数据传输速率（“用户体验的数据传输速率”为 100 Mbps）。很难想象什么样的 app 会需要如此多的数据，而 5G 支持者们似乎觉得一切皆有可能。5G 在实践中意味着什么？我们需要好好想想它能为现实世界带来什么样的变化。</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">使用 VS Code 调试 Xv6</title>
      
      
      <link href="/2020/01/23/vscode-debugging-xv6/" rel="alternate" type="text/html" title="使用 VS Code 调试 Xv6" />
      
      <published>2020-01-23T00:00:00+00:00</published>
      <updated>2020-01-23T00:00:00+00:00</updated>
      <id>/2020/01/23/vscode-debugging-xv6</id>
      <content type="html" xml:base="/2020/01/23/vscode-debugging-xv6/">&lt;p&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2019/xv6.html&quot;&gt;Xv6&lt;/a&gt; 是MIT 开发的一个教学使用的类 Unix 操作系统，&lt;a href=&quot;https://github.com/mit-pdos/xv6-public&quot;&gt;开源&lt;/a&gt;并且配有“&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf&quot;&gt;课本&lt;/a&gt;”。相比大而全的教科书，它更加精简，只包含部分核心的操作系统思想和概念；又更加具体，完全可以从源码层面去看如何简单地实现进程、页表、锁这些基础设施，很适合在离开学校之后拿来补课。&lt;/p&gt;

&lt;p&gt;除了课本和注释，阅读和理解一份源码最有效的方式就是把它跑起来、调试起来，下面会说明怎么用在 macOS 下运行和使用 VS Code 调试 Xv6 内核。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;如何运行-xv6&quot;&gt;如何运行 Xv6&lt;/h3&gt;

&lt;p&gt;课程官网或一些博客都能找到关于运行 Xv6 的介绍，这里就只简单写一下步骤。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;把&lt;a href=&quot;https://github.com/mit-pdos/xv6-public.git&quot;&gt;代码&lt;/a&gt; 下载到 Mac 上；&lt;/li&gt;
  &lt;li&gt;安装 Xcode 命令行工具和 Homebrew（如果还没有的话）；&lt;/li&gt;
  &lt;li&gt;按照&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2019/tools.html&quot;&gt;官网的指引&lt;/a&gt;安装运行 Xv6 依赖的 qemu、riscv-tools；&lt;/li&gt;
  &lt;li&gt;这时，&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 到代码目录，&lt;code class=&quot;highlighter-rouge&quot;&gt;make qemu&lt;/code&gt; 应该就可以编译和运行了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/xv6/run-xv6.png&quot; alt=&quot;run xv6&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;如何调试-xv6&quot;&gt;如何调试 Xv6&lt;/h3&gt;

&lt;p&gt;课本第二章章末练习中介绍到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;make qemu-gdb&lt;/code&gt; 就是用于调试的命令，提供启动时等待 debugger attach 的能力，在另一个命令行窗口中运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 时，gdb 就会 attach 到等待运行的 Xv6 上。&lt;/p&gt;

&lt;p&gt;新版本的 macOS 没有自带 gdb，所以需要先安装&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;gdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但这时由于 riscv-gnu-toolchain 和 gdb link 了同一个文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;jit-reader.h&lt;/code&gt;，会导致 gdb 安装中断，可根据 brew 的提示运行&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--overwrite&lt;/span&gt; gdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时再运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make qemu-gdb&lt;/code&gt;，应该就会看到命令行进入等待 gdb attach 的状态，在其他窗口中运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;，就可以按练习中的方式设置断点和其他调试了。&lt;/p&gt;

&lt;h3 id=&quot;如何使用-vs-code-调试-xv6&quot;&gt;如何使用 VS Code 调试 Xv6&lt;/h3&gt;

&lt;p&gt;如果用顺手的 IDE 取代命令行的 gdb 来做 attach ，调试会方便得多。&lt;/p&gt;

&lt;p&gt;为了方便编译，先添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vscode/task.json&lt;/code&gt;，添加后可以通过 command+shift+B 在 VS Code 的 terminal 中运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make qemu-gdb&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2.0.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;compile and run xv6 in debug mode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;command&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bash&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;args&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;make &amp;amp;&amp;amp; make qemu-gdb&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;presentation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;echo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;reveal&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;always&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;focus&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;panel&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;new&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;showReuseMessage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;clear&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;group&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;kind&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;isDefault&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vscode/launch.json&lt;/code&gt; 文件如下，就可以在 VS Code 的 debug 面板中看到相应的运行选项。需要注意的是，这个配置只负责 attach，点击 run 之前需要先运行上面的 task 或手动在命令行跑 &lt;code class=&quot;highlighter-rouge&quot;&gt;make qemu-gdb&lt;/code&gt;，并把 &lt;code class=&quot;highlighter-rouge&quot;&gt;miDebuggerServerAddress&lt;/code&gt; 改成 terminal 中最后输出的端口号&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.2.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;configurations&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Remote Debug Xv6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cppdbg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;request&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;launch&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;miDebuggerServerAddress&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:25502&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;program&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceRoot}/kernel/kernel&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;cwd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;MIMode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gdb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;externalConsole&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;serverLaunchTimeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;stopAtEntry&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;logging&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;engineLogging&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel/main.c&lt;/code&gt; 中打个断点，点 run 就会看到 Xv6 的运行被中断了。🎉&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/xv6/debug-xv6.png&quot; alt=&quot;debug-xv6&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;one-more-thing&quot;&gt;One more thing&lt;/h3&gt;

&lt;p&gt;再对其他函数做进一步的调试会发现，运行时代码里的很多符号被优化掉了，原因是 Makefile 没有对调试模式的编译选项做额外处理，由于是出于学习目的跑 Xv6，为了方便直接把两种运行模式的编译优化都关掉&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile line 57&lt;/span&gt;
CFLAGS &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Werror&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-fno-omit-frame-pointer&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ggdb&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候再编译会先后报几个问题，根据错误信息一一处理掉即可&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile line 60&lt;/span&gt;
CFLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ffreestanding&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-fno-common&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-mno-relax&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// user/usertests.c line 2123&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// user/usertests.c line 2186&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strcmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可参考&lt;a href=&quot;https://github.com/lihaoyuan/xv6-riscv/commit/b2930ce6bed375f252bb73ce7069ecbf96100345&quot;&gt;这个提交&lt;/a&gt;。&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>lhy</name>
          
          
        </author>
      

      

      
        <category term="os" />
      
        <category term="xv6" />
      

      
        <summary type="html">Xv6 是MIT 开发的一个教学使用的类 Unix 操作系统，开源并且配有“课本”。相比大而全的教科书，它更加精简，只包含部分核心的操作系统思想和概念；又更加具体，完全可以从源码层面去看如何简单地实现进程、页表、锁这些基础设施，很适合在离开学校之后拿来补课。 除了课本和注释，阅读和理解一份源码最有效的方式就是把它跑起来、调试起来，下面会说明怎么用在 macOS 下运行和使用 VS Code 调试 Xv6 内核。</summary>
      

      
      
    </entry>
  
  
</feed>
